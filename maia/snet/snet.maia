///
/// @license
/// Copyright 2020 Roberto Luiz Souza Monteiro,
///                Renata Souza Barreto,
///                Hernane Borges de Barros Pereira.
///
/// Licensed under the Apache License, Version 2.0 (the 'License');
/// you may not use this file except in compliance with the License.
/// You may obtain a copy of the License at;
///
///   http://www.apache.org/licenses/LICENSE-2.0;
///
/// Unless required by applicable law or agreed to in writing, software;
/// distributed under the License is distributed on an 'AS IS' BASIS,
/// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, eitherMath.express or implied.
/// See the License for the specific language governing permissions and;
/// limitations under the License.
///

 ///
 /// Library for building semantic networks.
 /// @namespace snet
 ///
namespace snet {
    ///
    /// Convert a file in DLF format to JSON.
    /// @method dlfFileToJson
    /// @memberof snet
    /// @param {string}   fileContents - DLF file contents.
    /// @param {object}   properties - Network properties (n, m and directed).
    /// @param {string}   topology - Network topology. It can be:
    ///                              chain, circle or clique.
    /// @param {boolean}  weighted - The created network must be weighted based
    ///                              on the number of occurrences of the connections
    ///                              between the vertices.
    /// @return {object}  A JSON containing the network.
    ///
    function dlfFileToJson(fileContents, properties, topology, weighted) {
        if (core.type(properties) == "undefined") {
            properties = {
                "n": 0,
                "m": 0,
                "directed": false
            }
        } else {
            properties.n = 0
            properties.m = 0
            properties.directed = false
        }
        if (core.type(topology) == "undefined") {
            topology = "chain"
        }
        if (core.type(weighted) == "undefined") {
            weighted = true
        }
        
        network = {
            "nodes": [],
            "edges": []
        }

        fileSection = "none"
        fileLines = core.split(core.replace(fileContents, "\r\n", "\n"), "\n")
        for (l = 0; l < fileLines.length; l = l + 1) {
            line = fileLines[l]
            record = core.splitCSV(line.trim(), " ", true)
            if ((core.toLowerCase(record[0]) == "*vertices") || (core.toLowerCase(record[0]) == "*edges") || (core.toLowerCase(record[0]) == "*arcs") || (core.toLowerCase(record[0]) == "*matrix")) {
                fileSection = core.toLowerCase(record[0])
                if (fileSection == "*vertices") {
                    n = ""
                    for (j = 1; j < record.length; j = j + 1) {
                        if (record[j] == "") {
                            continue
                        }
                        if (n == "") {
                            n = core.toNumber(record[j])
                            break
                        }
                    }
                    if (n == "") {
                        break
                    } else {
                        properties.n = n
                    }
                } elseif (fileSection == "*arcs") {
                    properties.directed = true
                }
                i = 0
                continue
            }
            if (core.length(record) >= 2) {
                if (fileSection == "*vertices") {
                    id = ""
                    label = ""
                    x = ""
                    y = ""
                    size = ""
                    for (j = 0; j < record.length; j = j + 1) {
                        if (record[j] == "") {
                            continue
                        }
                        if (id == "") {
                            id = core.toString(record[j])
                            continue
                        }
                        if (label == "") {
                            label = core.replace(record[j], core.regExp("\"", "g"), "")
                            continue
                        }
                        if (x == "") {
                            x = core.toNumber(record[j])
                            continue
                        }
                        if (y == "") {
                            y = core.toNumber(record[j])
                            continue
                        }
                        if (size == "") {
                            if (core.type(record[j]) == "number") {
                                size = core.toNumber(record[j])
                            }
                        }
                    }
                    if (x == "") {
                        x = math.random()
                    }
                    if (y == "") {
                        y = math.random()
                    }
                    if (size == "") {
                        size = 1
                    }
                    node = {
                        "id": "n" + id,
                        "label": label,
                        "x": x,
                        "y": y,
                        "size": size
                    }
                    network.nodes.push(node)
                    i = i + 1
                } elseif (fileSection == "*edges") {
                    source = ""
                    target = ""
                    weight = ""
                    for (j = 0; j < record.length; j = j + 1) {
                        if (record[j] == "") {
                            continue
                        }
                        if (source == "") {
                            source = core.toNumber(record[j])
                            continue
                        }
                        if (target == "") {
                            target = core.toNumber(record[j])
                            continue
                        }
                        if (weight == "") {
                            if (core.type(record[j]) == "number") {
                                weight = core.toNumber(record[j])
                            }
                            continue
                        }
                    }
                    if (weight == "") {
                        weight = 1
                    }
                    edge = {
                        "id": "e" + core.toString(i),
                        "source": "n" + core.toString(source),
                        "target": "n" + core.toString(target),
                        "size": weight
                    }
                    network.edges.push(edge)
                    i = i + 1
                    properties.m = properties.m + 1
                } elseif (fileSection == "*arcs") {
                    source = ""
                    target = ""
                    weight = ""
                    for (j = 0; j < record.length; j = j + 1) {
                        if (record[j] == "") {
                            continue
                        }
                        if (source == "") {
                            source = core.toNumber(record[j])
                            continue
                        }
                        if (target == "") {
                            target = core.toNumber(record[j])
                            continue
                        }
                        if (weight == "") {
                            weight = core.toNumber(record[j])
                            continue
                        }
                    }
                    if (weight == "") {
                        weight = 1
                    }
                    edge = {
                        "id": "e" + core.toString(i),
                        "source": "n" + core.toString(source),
                        "target": "n" + core.toString(target),
                        "size": weight
                    }
                    network.edges.push(edge)
                    i = i + 1
                    properties.m = properties.m + 1
                }
            }
        }
        return(network)
    }
}
